import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/task_model.dart';
import '../models/task_assignment_model.dart';
import '../models/progress_request_model.dart';
import '../models/user_model.dart';

class TaskService {
  FirebaseFirestore? _dbInstance;
  FirebaseFirestore get _db {
    try {
      return _dbInstance ??= FirebaseFirestore.instance;
    } catch (e) {
      throw Exception('Firebase not initialized.');
    }
  }

  // ── CREATE TASK ───────────────────────────────────────────────
  Future<String> createTask({
    required String title,
    required String description,
    required String adminId,
    required String ngoId,
    required int maxVolunteers,
    required DateTime deadline,
  }) async {
    final ref = _db.collection('tasks').doc();
    await ref.set({
      'title': title,
      'description': description,
      'adminId': adminId,
      'ngoId': ngoId,
      'maxVolunteers': maxVolunteers,
      'assignedVolunteers': [],
      'pendingInvites': [],
      'declinedBy': [],
      'status': 'inviting',
      'mainProgress': 0.0,
      'createdAt': FieldValue.serverTimestamp(),
      'deadline': Timestamp.fromDate(deadline),
      'inviteDeadline': Timestamp.fromDate(DateTime.now().add(const Duration(hours: 24))),
      'adminFinalNote': '',
    });
    return ref.id;
  }

  // ── STREAMS ───────────────────────────────────────────────────
  Stream<List<TaskModel>> streamAdminTasks(String adminId) {
    return _db
        .collection('tasks')
        .where('adminId', isEqualTo: adminId)
        .snapshots()
        .map(
          (snap) =>
              snap.docs.map((d) => TaskModel.fromMap(d.data(), d.id)).toList(),
        );
  }

  Stream<List<ProgressRequestModel>> streamPendingRequestsForAdmin(
    String adminId,
  ) {
    return _db
        .collection('progress_requests')
        .where('adminId', isEqualTo: adminId)
        .where('status', isEqualTo: 'pending')
        .snapshots()
        .map(
          (snap) => snap.docs
              .map((d) => ProgressRequestModel.fromMap(d.data(), d.id))
              .toList(),
        );
  }

  Stream<List<TaskAssignmentModel>> streamTaskAssignments(String taskId) {
    return _db
        .collection('task_assignments')
        .where('taskId', isEqualTo: taskId)
        .snapshots()
        .map(
          (snap) => snap.docs
              .map((d) => TaskAssignmentModel.fromMap(d.data(), d.id))
              .toList(),
        );
  }

  Stream<TaskModel?> streamTask(String taskId) {
    return _db.collection('tasks').doc(taskId).snapshots().map((doc) {
      if (!doc.exists) return null;
      return TaskModel.fromMap(doc.data()!, doc.id);
    });
  }

  Stream<List<UserModel>> streamNgoVolunteers(String ngoId) {
    return _db
        .collection('users')
        .where('ngoId', isEqualTo: ngoId)
        .where('role', isEqualTo: 'volunteer')
        .snapshots()
        .map(
          (snap) =>
              snap.docs.map((d) => UserModel.fromMap(d.data(), d.id)).toList(),
        );
  }

  // ── INVITE VOLUNTEERS ─────────────────────────────────────────
  Future<void> inviteVolunteers(
    String taskId,
    List<String> volunteerIds,
  ) async {
    await _db.collection('tasks').doc(taskId).update({
      'pendingInvites': FieldValue.arrayUnion(volunteerIds),
    });
  }

  Future<void> cancelInvite(String taskId, String volunteerId) async {
    await _db.collection('tasks').doc(taskId).update({
      'pendingInvites': FieldValue.arrayRemove([volunteerId]),
    });
  }

  // ── APPROVE PROGRESS REQUEST ──────────────────────────────────
  Future<void> approveProgressRequest(ProgressRequestModel request) async {
    final assignSnap = await _db
        .collection('task_assignments')
        .where('taskId', isEqualTo: request.taskId)
        .where('volunteerId', isEqualTo: request.volunteerId)
        .limit(1)
        .get();

    if (assignSnap.docs.isEmpty) {
      throw Exception('Assignment not found for this volunteer.');
    }

    final assignmentRef = assignSnap.docs.first.reference;

    final batch = _db.batch();
    batch.update(assignmentRef, {
      'individualProgress': request.requestedProgress,
    });
    batch.update(_db.collection('progress_requests').doc(request.requestId), {
      'status': 'approved',
    });
    await batch.commit();

    await _recalculateMainProgress(request.taskId);
  }

  // ── REJECT PROGRESS REQUEST ───────────────────────────────────
  Future<void> rejectProgressRequest(ProgressRequestModel request) async {
    await _db.collection('progress_requests').doc(request.requestId).update({
      'status': 'rejected',
    });
  }

  // ── REMOVE VOLUNTEER FROM TASK ────────────────────────────────
  Future<void> removeVolunteer(String taskId, String volunteerId) async {
    final assignSnap = await _db
        .collection('task_assignments')
        .where('taskId', isEqualTo: taskId)
        .where('volunteerId', isEqualTo: volunteerId)
        .limit(1)
        .get();

    final batch = _db.batch();

    if (assignSnap.docs.isNotEmpty) {
      batch.delete(assignSnap.docs.first.reference);
    }

    batch.update(_db.collection('tasks').doc(taskId), {
      'assignedVolunteers': FieldValue.arrayRemove([volunteerId]),
    });

    final pendingReqs = await _db
        .collection('progress_requests')
        .where('taskId', isEqualTo: taskId)
        .where('volunteerId', isEqualTo: volunteerId)
        .where('status', isEqualTo: 'pending')
        .get();

    for (final doc in pendingReqs.docs) {
      batch.update(doc.reference, {'status': 'rejected'});
    }

    await batch.commit();
    await _recalculateMainProgress(taskId);
  }

  // ── COMPLETE TASK ─────────────────────────────────────────────
  Future<void> completeTask(String taskId, String finalNote) async {
    final batch = _db.batch();
    batch.update(_db.collection('tasks').doc(taskId), {
      'status': 'completed',
      'adminFinalNote': finalNote,
      'mainProgress': 100.0,
    });

    final chatSnap = await _db
        .collection('chats')
        .where('taskId', isEqualTo: taskId)
        .limit(1)
        .get();

    if (chatSnap.docs.isNotEmpty) {
      batch.update(chatSnap.docs.first.reference, {'isArchived': true});
    }

    await batch.commit();
  }

  // ── VOLUNTEER STREAMS ──────────────────────────────────────────

  /// All tasks belonging to an NGO.
  Stream<List<TaskModel>> streamNgoTasks(String ngoId) {
    return _db
        .collection('tasks')
        .where('ngoId', isEqualTo: ngoId)
        .snapshots()
        .map((snap) =>
            snap.docs.map((d) => TaskModel.fromMap(d.data(), d.id)).toList());
  }

  /// Tasks where the volunteer is in assignedVolunteers.
  Stream<List<TaskModel>> streamVolunteerAssignedTasks(String volunteerId) {
    return _db
        .collection('tasks')
        .where('assignedVolunteers', arrayContains: volunteerId)
        .snapshots()
        .map((snap) =>
            snap.docs.map((d) => TaskModel.fromMap(d.data(), d.id)).toList());
  }

  /// Tasks where the volunteer has a pending invite.
  Stream<List<TaskModel>> streamVolunteerInvites(String volunteerId) {
    return _db
        .collection('tasks')
        .where('pendingInvites', arrayContains: volunteerId)
        .snapshots()
        .map((snap) =>
            snap.docs.map((d) => TaskModel.fromMap(d.data(), d.id)).toList());
  }

  /// Get the volunteer's individual assignment for a task.
  Future<TaskAssignmentModel?> getVolunteerAssignment(
    String taskId,
    String volunteerId,
  ) async {
    final snap = await _db
        .collection('task_assignments')
        .where('taskId', isEqualTo: taskId)
        .where('volunteerId', isEqualTo: volunteerId)
        .limit(1)
        .get();
    if (snap.docs.isEmpty) return null;
    return TaskAssignmentModel.fromMap(
        snap.docs.first.data(), snap.docs.first.id);
  }

  /// Stream the volunteer's assignment for a specific task.
  Stream<TaskAssignmentModel?> streamVolunteerAssignment(
    String taskId,
    String volunteerId,
  ) {
    return _db
        .collection('task_assignments')
        .where('taskId', isEqualTo: taskId)
        .where('volunteerId', isEqualTo: volunteerId)
        .limit(1)
        .snapshots()
        .map((snap) {
      if (snap.docs.isEmpty) return null;
      return TaskAssignmentModel.fromMap(
          snap.docs.first.data(), snap.docs.first.id);
    });
  }

  // ── ACCEPT / DECLINE INVITATIONS ──────────────────────────────

  /// Volunteer accepts an invitation: move from pendingInvites → assignedVolunteers
  /// and create a task_assignment document.
  Future<void> acceptInvite(String taskId, String volunteerId) async {
    final batch = _db.batch();

    // Move volunteer from pendingInvites to assignedVolunteers
    final taskRef = _db.collection('tasks').doc(taskId);
    batch.update(taskRef, {
      'pendingInvites': FieldValue.arrayRemove([volunteerId]),
      'assignedVolunteers': FieldValue.arrayUnion([volunteerId]),
    });

    // Create a task_assignment
    final assignRef = _db.collection('task_assignments').doc();
    batch.set(assignRef, {
      'taskId': taskId,
      'volunteerId': volunteerId,
      'individualProgress': 0.0,
    });

    await batch.commit();

    // Only auto-activate if ALL required volunteer slots are filled
    final taskDoc = await taskRef.get();
    if (taskDoc.exists) {
      final task = TaskModel.fromMap(taskDoc.data()!, taskDoc.id);
      if (task.status == 'inviting' &&
          task.assignedVolunteers.length >= task.maxVolunteers) {
        await taskRef.update({'status': 'active'});
      }
    }
  }

  /// Volunteer declines an invitation.
  Future<void> declineInvite(String taskId, String volunteerId) async {
    await _db.collection('tasks').doc(taskId).update({
      'pendingInvites': FieldValue.arrayRemove([volunteerId]),
      'declinedBy': FieldValue.arrayUnion([volunteerId]),
    });
  }

  // ── JOIN / DISMISS TASK (from NGO Tasks) ──────────────────────

  /// Volunteer joins a task directly (not through invitation).
  Future<void> joinTask(String taskId, String volunteerId) async {
    final taskDoc = await _db.collection('tasks').doc(taskId).get();
    if (!taskDoc.exists) throw Exception('Task not found.');
    final task = TaskModel.fromMap(taskDoc.data()!, taskDoc.id);

    if (task.assignedVolunteers.contains(volunteerId)) {
      throw Exception('Already assigned to this task.');
    }
    if (task.assignedVolunteers.length >= task.maxVolunteers) {
      throw Exception('Task is full.');
    }
    if (task.status == 'completed') {
      throw Exception('Task is already completed.');
    }

    final batch = _db.batch();
    final taskRef = _db.collection('tasks').doc(taskId);
    batch.update(taskRef, {
      'assignedVolunteers': FieldValue.arrayUnion([volunteerId]),
      'pendingInvites': FieldValue.arrayRemove([volunteerId]),
      'declinedBy': FieldValue.arrayRemove([volunteerId]),
    });

    final assignRef = _db.collection('task_assignments').doc();
    batch.set(assignRef, {
      'taskId': taskId,
      'volunteerId': volunteerId,
      'individualProgress': 0.0,
    });

    await batch.commit();

    // Only auto-activate if ALL required volunteer slots are filled
    final updatedDoc = await taskRef.get();
    if (updatedDoc.exists) {
      final updatedTask = TaskModel.fromMap(updatedDoc.data()!, updatedDoc.id);
      if (updatedTask.status == 'inviting' &&
          updatedTask.assignedVolunteers.length >= updatedTask.maxVolunteers) {
        await taskRef.update({'status': 'active'});
      }
    }
  }

  /// Volunteer dismisses a task they're not interested in.
  Future<void> dismissTask(String taskId, String volunteerId) async {
    await _db.collection('tasks').doc(taskId).update({
      'declinedBy': FieldValue.arrayUnion([volunteerId]),
    });
  }

  // ── SUBMIT PROGRESS REQUEST ───────────────────────────────────

  /// Volunteer submits a progress update request for admin approval.
  Future<void> submitProgressRequest({
    required String taskId,
    required String taskTitle,
    required String volunteerId,
    required String adminId,
    required double currentProgress,
    required double requestedProgress,
    required String note,
  }) async {
    final ref = _db.collection('progress_requests').doc();
    await ref.set({
      'taskId': taskId,
      'taskTitle': taskTitle,
      'volunteerId': volunteerId,
      'adminId': adminId,
      'currentProgress': currentProgress,
      'requestedProgress': requestedProgress,
      'mandatoryNote': note,
      'status': 'pending',
      'createdAt': FieldValue.serverTimestamp(),
    });
  }

  /// Stream progress requests for a specific volunteer on a task.
  Stream<List<ProgressRequestModel>> streamVolunteerProgressRequests(
    String taskId,
    String volunteerId,
  ) {
    return _db
        .collection('progress_requests')
        .where('taskId', isEqualTo: taskId)
        .where('volunteerId', isEqualTo: volunteerId)
        .snapshots()
        .map((snap) => snap.docs
            .map((d) => ProgressRequestModel.fromMap(d.data(), d.id))
            .toList());
  }

  // ── INTERNAL: Recalculate mainProgress ───────────────────────
  Future<void> _recalculateMainProgress(String taskId) async {
    final taskDoc = await _db.collection('tasks').doc(taskId).get();
    if (!taskDoc.exists) return;

    final task = TaskModel.fromMap(taskDoc.data()!, taskDoc.id);
    final assignedCount = task.assignedVolunteers.length;

    if (assignedCount == 0) {
      await _db.collection('tasks').doc(taskId).update({'mainProgress': 0.0});
      return;
    }

    final assignSnap = await _db
        .collection('task_assignments')
        .where('taskId', isEqualTo: taskId)
        .get();

    double sum = 0;
    for (final doc in assignSnap.docs) {
      sum += (doc.data()['individualProgress'] ?? 0.0).toDouble();
    }

    final mainProgress = sum / assignedCount;
    final updates = <String, dynamic>{'mainProgress': mainProgress};

    if (mainProgress >= 100.0 && task.status != 'completed') {
      updates['status'] = 'completed';
    }

    await _db.collection('tasks').doc(taskId).update(updates);
  }

  // ── ACTIVATE TASK (admin choice after invite period) ─────────
  Future<void> activateTask(String taskId) async {
    await _db.collection('tasks').doc(taskId).update({'status': 'active'});
  }

  // ── DELETE TASK ────────────────────────────────────────────────
  Future<void> deleteTask(String taskId) async {
    final batch = _db.batch();

    final assignments = await _db
        .collection('task_assignments')
        .where('taskId', isEqualTo: taskId)
        .get();
    for (final doc in assignments.docs) {
      batch.delete(doc.reference);
    }

    final requests = await _db
        .collection('progress_requests')
        .where('taskId', isEqualTo: taskId)
        .get();
    for (final doc in requests.docs) {
      batch.delete(doc.reference);
    }

    final chats = await _db
        .collection('chats')
        .where('taskId', isEqualTo: taskId)
        .get();
    for (final doc in chats.docs) {
      batch.delete(doc.reference);
    }

    batch.delete(_db.collection('tasks').doc(taskId));
    await batch.commit();
  }
}
